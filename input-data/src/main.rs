// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use input_data_methods::{HEART_DISEASE_DATA_ID, HEART_DISEASE_DATA_ELF};
use input_data_utils::HeartDiseaseMeasure;
use risc0_zkvm::{default_prover, ExecutorEnv};

use std::{error::Error, fs::write};

/// Given an secp256k1 verifier key (i.e. public key), message and signature,
/// runs the ECDSA verifier inside the zkVM and returns a receipt, including a
/// journal and seal attesting to the fact that the prover knows a valid
/// signature from the committed public key over the committed message.
fn main() -> Result<(), Box<dyn Error>> {
    
    let input_file_path = include_str!("../data/heart+disease/output/signed.cleveland.data.csv");
    let output_file_path = "out/proof_of_deserialization";

    // Run signature verified in the zkVM guest and get the resulting receipt.
    let env = ExecutorEnv::builder()
        .write(&input_file_path)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove(env, HEART_DISEASE_DATA_ELF).unwrap().receipt;

    // Verify the receipt and then access the journal.
    receipt.verify(HEART_DISEASE_DATA_ID).expect("Verification failed");
    let measures: Vec<HeartDiseaseMeasure> = receipt.journal.decode()?;
    
    // Save the receipt to disk so it can be sent to the verifier.
    write(output_file_path, bincode::serialize(&receipt).unwrap())?;
    println!("Success! Saved the receipt to {}", output_file_path);

    Ok(())
}
